# Update bl_info for translation support
bl_info = {
    "name": "Bakin VRM",
    "author": "Meringue Rouge",
    "version": (6, 2, 0),
    "blender": (2, 80, 0),
    "location": "View3D > Tool Shelf > Run Script Button",
    "description": "Adds buttons that create itemhook bones and shape keys for both eye and head movement for VRoid VRM characters, for use with RPG Developer Bakin.",
    "category": "Development",
}

import bpy
import os
import math
import mathutils
import textwrap
import bmesh

def update_animation_name(self, context):
    return None

bpy.types.Scene.animation_name = bpy.props.StringProperty(
    name="Animation Name",
    default="Idle",
    update=update_animation_name
)

# Translation dictionary
translations_dict = {
    "ja_JP": {
        ("Operator", "Import VRM"): "VRMをインポート",
        ("Operator", "Import the VRM model into Blender. You need to have the VRM addon for Blender for this to work. This is the same as doing the Import from the File menu. There is no need to enable Texture export, as the export on this addon will handle everything."): "VRMモデルをBlenderにインポートします。この機能を使用するには、Blender用のVRMアドオンが必要です。ファイルメニューからのインポートと同じです。テクスチャのエクスポートを有効にする必要はありません。このアドオンのエクスポート機能がすべて処理します。",
        ("Operator", "Export VRM for Bakin"): "Bakin用VRMをエクスポート",
        ("Operator", "Exports the scene as a VRM file using the model's name"): "モデルの名前を使用してシーンをVRMファイルとしてエクスポートします",
        ("Operator", "Add Item Hooks"): "アイテムフックを追加",
        ("Operator", "Adds Item Hook bones to the left and right hand of the VRM model. This will let you hold items in either hand using the 'Attach Model to Cast' event in Bakin."): "VRMモデルの左右の手にアイテムフックのボーンを追加します。これにより、Bakinの「モデルをキャストにアタッチ」イベントを使用して両手でアイテムを持つことができます。",
        ("Operator", "Add Eye Shape Keys"): "目のシェイプキーを追加",
        ("Operator", "Adds Shape Keys for eye positioning. This will let you pose the eyes in real time using BAKIN's Blend Shapes."): "目の位置調整用のシェイプキーを追加します。これにより、Bakinのブレンドシェイプを使用してリアルタイムで目をポーズできます。",
        ("Operator", "Add Head + Body Shape Keys"): "頭部＋体シェイプキーを追加",
        ("Operator", "Adds Shape Keys for head tilt/rotation and body movement. This will let you pose the head and body in real time using BAKIN's Blend Shapes."): "頭部の傾き/回転および体の動き用のシェイプキーを追加します。これにより、Bakinのブレンドシェイプを使用して頭部と体をリアルタイムでポーズできます。",
        ("Operator", "Fusion Meshes and Hair/Head Keys"): "メッシュとヘア/ヘッドキーの融合",
        ("Operator", "Strongly recommended (8 materials / unlimited materials only). Merges available meshes (Body, Face, Hair) together and merges both head and hair shape keys into a new Head shapekey that handles both at once!"): "強く推奨（8マテリアル/無制限マテリアルのみ）。利用可能なメッシュ（ボディ、顔、髪）を統合し、頭部と髪のシェイプキーを新しいヘッドシェイプキーに統合して同時に処理します！",
        ("Operator", "Eyewear Only: Split, Export & Delete"): "アイウェアのみ：分割、エクスポート、削除",
        ("Operator", "Isolates glasses from the VRM model, cleans up materials and shape keys, and optionally exports and deletes them."): "VRMモデルからメガネを分離し、マテリアルとシェイプキーを整理し、オプションでエクスポートおよび削除します。",
        ("Operator", "Extract Cat Ears BETA"): "猫耳を抽出（ベータ）",
        ("Operator", "Isolates any cat ears on your VRM model so that you can load them separately through BAKIN's Subgraphics. At present, you'll need to export this separately through the Blender FBX exporter, select the ears alone, limit export to selected only, then delete it and export the rest of the model through the addon."): "VRMモデルの猫耳を分離し、Bakinのサブグラフィックスで個別に読み込めるようにします。現在は、BlenderのFBXエクスポートで耳のみを選択し、選択したもののみをエクスポートし、削除した後、残りのモデルをアドオンでエクスポートする必要があります。",
        ("Operator", "Extract Rabbit Ears BETA"): "ウサギ耳を抽出（ベータ）",
        ("Operator", "Isolates any rabbit ears on your VRM model so that you can load them separately through BAKIN's Subgraphics. At present, you'll need to export this separately through the Blender FBX exporter, select the ears alone, limit export to selected only, then delete it and export the rest of the model through the addon."): "VRMモデルのウサギ耳を分離し、Bakinのサブグラフィックスで個別に読み込めるようにします。現在は、BlenderのFBXエクスポートで耳のみを選択し、選択したもののみをエクスポートし、削除した後、残りのモデルをアドオンでエクスポートする必要があります。",
        ("Operator", "Export FBX + DEF (Unified)"): "FBX + DEFをエクスポート（統一）",
        ("Operator", "Exports the FBX model, textures, and DEF file for RPG Developer BAKIN. Choose material type for export based on the 'Materials Reduced' setting you've exported the model from VRoid Studio: 8 or 2 materials, or without Materials Reduced."): "RPG Developer Bakin用にFBXモデル、テクスチャ、DEFファイルをエクスポートします。VRoid Studioからエクスポートしたモデルの「マテリアル削減」設定に基づいてエクスポートするマテリアルの種類を選択します：8または2マテリアル、またはマテリアル削減なし。",
        ("Operator", "Process FBX for Bakin"): "Bakin用FBXを処理",
        ("Operator", "Automates importing of the FBX generated by Bakin"): "Bakinで生成されたFBXのインポートを自動化します",
        ("Operator", "Create Alternate Irises"): "代替アイリスを作成",
        ("Operator", "Creates alternative irises that can be displayed as emotions through blend shapes in Bakin! IMPORTANT: Provide it with a 4096x4096 image. The image is divided into 4 blocks of 2048x2048px, and within each block, the irises are situated in the bottom half, with the eye highlights in the top half of each section. Try out the template image on the github!"): "Bakinでブレンドシェイプを通じて感情として表示できる代替アイリスを作成します！重要：4096x4096の画像を提供してください。画像は2048x2048ピクセルの4つのブロックに分割され、各ブロック内でアイリスは下半分に、目のハイライトは上半分に配置されます。GitHubのテンプレート画像を試してください！",
        ("Operator", "Create Blushing Layer"): "赤面レイヤーを作成",
        ("Operator", "Creates a transparent blushing layer over the face with blend shapes for Bakin. Provide a 2048x2048 image divided into 4 blocks of 1024x1024px for each blush variation."): "Bakin用に顔の上に透明な赤面レイヤーをブレンドシェイプで作成します。2048x2048の画像を提供し、各赤面バリエーション用に1024x1024ピクセルの4つのブロックに分割してください。",
        ("Operator", "Export _base_ Animation"): "_base_アニメーションをエクスポート",
        ("Operator", "Exports the _base_ armature animation as an FBX clip"): "_base_アーマチュアアニメーションをFBXクリップとしてエクスポートします",
        ("Operator", "Enter Animation Name"): "アニメーション名を入力",
        ("*", "Import"): "インポート",
        ("*", "Bakin Enhancements"): "Bakin拡張機能",
        ("*", "Optional Expressions"): "オプションの表情",
        ("*", "Head Tilt"): "頭の傾き",
        ("*", "Split/Export/Delete Subgraphics"): "サブグラフィックスの分割/エクスポート/削除",
        ("*", "Warning: Blend file not saved!"): "警告：ブレンドファイルが保存されていません！",
        ("*", "Separate Only Mode"): "分離のみモード",
        ("*", "Export VRM for Bakin"): "Bakin用VRMエクスポート",
        ("*", "Animation Exporter"): "アニメーションエクスポート",
        ("*", "Animation Retargeting is installed."): "アニメーションリターゲティングがインストールされています。",
        ("*", "Animation Retargeting not found. Please download:"): "アニメーションリターゲティングが見つかりません。ダウンロードしてください：",
        ("*", "Download Animation Retargeting"): "アニメーションリターゲティングをダウンロード",
        ("*", "VRM only: import the model into Bakin before animating!"): "VRMのみ：アニメーション前にモデルをBakinにインポートしてください！",
        ("*", "Anim Name"): "アニメーション名",
    },
    "zh_CN": {
        ("Operator", "Import VRM"): "导入VRM",
        ("Operator", "Import the VRM model into Blender. You need to have the VRM addon for Blender for this to work. This is the same as doing the Import from the File menu. There is no need to enable Texture export, as the export on this addon will handle everything."): "将VRM模型导入Blender。需要安装Blender的VRM插件才能使用此功能。这与从文件菜单中执行导入操作相同。无需启用纹理导出，因为此插件的导出功能会处理一切。",
        ("Operator", "Export VRM for Bakin"): "为Bakin导出VRM",
        ("Operator", "Exports the scene as a VRM file using the model's name"): "使用模型的名称将场景导出为VRM文件",
        ("Operator", "Add Item Hooks"): "添加物品钩子",
        ("Operator", "Adds Item Hook bones to the left and right hand of the VRM model. This will let you hold items in either hand using the 'Attach Model to Cast' event in Bakin."): "为VRM模型的左右手添加物品钩子骨骼。这允许您使用Bakin中的“将模型附加到角色”事件在任一手中持有物品。",
        ("Operator", "Add Eye Shape Keys"): "添加眼睛形状键",
        ("Operator", "Adds Shape Keys for eye positioning. This will let you pose the eyes in real time using BAKIN's Blend Shapes."): "为眼睛定位添加形状键。这允许您使用Bakin的混合形状实时调整眼睛姿势。",
        ("Operator", "Add Head + Body Shape Keys"): "添加头部+身体形状键",
        ("Operator", "Adds Shape Keys for head tilt/rotation and body movement. This will let you pose the head and body in real time using BAKIN's Blend Shapes."): "为头部倾斜/旋转和身体移动添加形状键。这允许您使用Bakin的混合形状实时调整头部和身体姿势。",
        ("Operator", "Fusion Meshes and Hair/Head Keys"): "融合网格和头发/头部键",
        ("Operator", "Strongly recommended (8 materials / unlimited materials only). Merges available meshes (Body, Face, Hair) together and merges both head and hair shape keys into a new Head shapekey that handles both at once!"): "强烈推荐（仅限8种材质/无限制材质）。将可用网格（身体、脸部、头发）合并在一起，并将头部和头发形状键合并成一个新的头部形状键，同时处理两者！",
        ("Operator", "Eyewear Only: Split, Export & Delete"): "仅眼镜：分割、导出和删除",
        ("Operator", "Isolates glasses from the VRM model, cleans up materials and shape keys, and optionally exports and deletes them."): "从VRM模型中分离眼镜，清理材质和形状键，并可选择导出和删除它们。",
        ("Operator", "Extract Cat Ears BETA"): "提取猫耳（测试版）",
        ("Operator", "Isolates any cat ears on your VRM model so that you can load them separately through BAKIN's Subgraphics. At present, you'll need to export this separately through the Blender FBX exporter, select the ears alone, limit export to selected only, then delete it and export the rest of the model through the addon."): "从VRM模型中分离猫耳，以便通过Bakin的子图形单独加载。目前，您需要通过Blender的FBX导出器单独导出猫耳，仅选择耳朵，限制导出仅限选中内容，然后删除并通过插件导出剩余模型。",
        ("Operator", "Extract Rabbit Ears BETA"): "提取兔耳（测试版）",
        ("Operator", "Isolates any rabbit ears on your VRM model so that you can load them separately through BAKIN's Subgraphics. At present, you'll need to export this separately through the Blender FBX exporter, select the ears alone, limit export to selected only, then delete it and export the rest of the model through the addon."): "从VRM模型中分离兔耳，以便通过Bakin的子图形单独加载。目前，您需要通过Blender的FBX导出器单独导出兔耳，仅选择耳朵，限制导出仅限选中内容，然后删除并通过插件导出剩余模型。",
        ("Operator", "Export FBX + DEF (Unified)"): "导出FBX + DEF（统一）",
        ("Operator", "Exports the FBX model, textures, and DEF file for RPG Developer BAKIN. Choose material type for export based on the 'Materials Reduced' setting you've exported the model from VRoid Studio: 8 or 2 materials, or without Materials Reduced."): "为RPG Developer Bakin导出FBX模型、纹理和DEF文件。根据您从VRoid Studio导出的模型的“材质减少”设置选择导出的材质类型：8种或2种材质，或不减少材质。",
        ("Operator", "Process FBX for Bakin"): "为Bakin处理FBX",
        ("Operator", "Automates importing of the FBX generated by Bakin"): "自动化导入Bakin生成的FBX文件",
        ("Operator", "Create Alternate Irises"): "创建替代虹膜",
        ("Operator", "Creates alternative irises that can be displayed as emotions through blend shapes in Bakin! IMPORTANT: Provide it with a 4096x4096 image. The image is divided into 4 blocks of 2048x2048px, and within each block, the irises are situated in the bottom half, with the eye highlights in the top half of each section. Try out the template image on the github!"): "在Bakin中通过混合形状创建可显示为情感的替代虹膜！重要：请提供4096x4096的图像。图像分为4个2048x2048像素的块，每个块内虹膜位于下半部分，眼睛高光位于上半部分。请尝试GitHub上的模板图像！",
        ("Operator", "Create Blushing Layer"): "创建脸红层",
        ("Operator", "Creates a transparent blushing layer over the face with blend shapes for Bakin. Provide a 2048x2048 image divided into 4 blocks of 1024x1024px for each blush variation."): "为Bakin创建覆盖在脸上的透明脸红层，带有混合形状。请提供2048x2048的图像，分为4个1024x1024像素的块，每个块对应一种脸红变体。",
        ("Operator", "Export _base_ Animation"): "导出_base_动画",
        ("Operator", "Exports the _base_ armature animation as an FBX clip"): "将_base_骨骼动画导出为FBX片段",
        ("Operator", "Enter Animation Name"): "输入动画名称",
        ("*", "Import"): "导入",
        ("*", "Bakin Enhancements"): "Bakin增强功能",
        ("*", "Optional Expressions"): "可选表情",
        ("*", "Head Tilt"): "头部倾斜",
        ("*", "Split/Export/Delete Subgraphics"): "分割/导出/删除子图形",
        ("*", "Warning: Blend file not saved!"): "警告：未保存Blend文件！",
        ("*", "Separate Only Mode"): "仅分离模式",
        ("*", "Export VRM for Bakin"): "为Bakin导出VRM",
        ("*", "Animation Exporter"): "动画导出器",
        ("*", "Animation Retargeting is installed."): "动画重定向已安装。",
        ("*", "Animation Retargeting not found. Please download:"): "未找到动画重定向。请下载：",
        ("*", "Download Animation Retargeting"): "下载动画重定向",
        ("*", "VRM only: import the model into Bakin before animating!"): "仅VRM：在动画之前将模型导入Bakin！",
        ("*", "Anim Name"): "动画名称",
    }
}

# Register translations
def register_translations():
    bpy.app.translations.register(__name__, translations_dict)

def unregister_translations():
    bpy.app.translations.unregister(__name__)

class AddItemHooksButton(bpy.types.Operator):
    bl_idname = "object.add_item_hooks"
    bl_label = bpy.app.translations.pgettext("Add Item Hooks")
    bl_description = bpy.app.translations.pgettext("Adds Item Hook bones to the left and right hand of the VRM model. This will let you hold items in either hand using the 'Attach Model to Cast' event in Bakin.")

    def execute(self, context):
        # Push the current state to the undo stack
        bpy.ops.ed.undo_push(message="Run VRM Bakin Utils")

        # Check and delete the "glTF_not_exported" collection if it exists
        if "glTF_not_exported" in bpy.data.collections:
            bpy.data.collections.remove(bpy.data.collections["glTF_not_exported"])

        # Check and delete the "Icosphere" mesh if it exists
        if "Icosphere" in bpy.data.meshes:
            bpy.data.meshes.remove(bpy.data.meshes["Icosphere"])

        # Select the armature and enter edit mode
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects['Armature'].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects['Armature']
        bpy.ops.object.mode_set(mode='EDIT')

        # Add item hook bones to both hands
        for hand_bone_name in ['J_Bip_L_Hand', 'J_Bip_R_Hand']:
            bpy.ops.armature.select_all(action='DESELECT')
            hand_bone = bpy.data.armatures['Armature'].edit_bones[hand_bone_name]
            hand_bone.select = True

            # Determine the new bone name
            new_bone_name = 'L_itemhook' if 'L_' in hand_bone_name else 'R_itemhook'

            # Add a new bone called itemhook at the same position as the hand bone
            new_bone = bpy.data.armatures['Armature'].edit_bones.new(new_bone_name)
            offset = mathutils.Vector((0.06, 0.04, -0.02)) if 'L_' in hand_bone_name else mathutils.Vector((-0.06, 0.04, -0.02))
            new_bone.head = hand_bone.head + offset
            new_bone.tail = hand_bone.head + mathutils.Vector((hand_bone.tail.y - hand_bone.head.y, -hand_bone.tail.x + hand_bone.head.x, 0)) + offset if 'L_' in hand_bone_name else hand_bone.head + mathutils.Vector((hand_bone.tail.y - hand_bone.head.y, hand_bone.tail.x - hand_bone.head.x, 0)) + offset
            new_bone.parent = hand_bone
            new_bone.use_connect = False  # This keeps the offset when parenting

        # Switch back to object mode
        bpy.ops.object.mode_set(mode='OBJECT')
        
        return {'FINISHED'}


# Remove the existing AddHeadEyeShapeKeysButton class and replace with these two classes

class AddEyeShapeKeysButton(bpy.types.Operator):
    bl_idname = "object.add_eye_shape_keys"
    bl_label = bpy.app.translations.pgettext("Add Eye Shape Keys")
    bl_description = bpy.app.translations.pgettext("Adds Shape Keys for eye positioning. This will let you pose the eyes in real time using BAKIN's Blend Shapes.")

    def execute(self, context):
        # Define the rotations for eye shape keys only
        rotations = {
            "EYE_LR_RIGHT": ('Z', math.radians(-8), 'J_Adj_L_FaceEye', 'J_Adj_R_FaceEye'),
            "EYE_LR_LEFT": ('Z', math.radians(12), 'J_Adj_L_FaceEye', 'J_Adj_R_FaceEye'),
            "EYE_LR_UP": ('X', math.radians(-10), 'J_Adj_L_FaceEye', 'J_Adj_R_FaceEye'),
            "EYE_LR_DOWN": ('X', math.radians(10), 'J_Adj_L_FaceEye', 'J_Adj_R_FaceEye'),
            "EYE_R_INNER": ('Z', math.radians(-8), 'J_Adj_R_FaceEye'),
            "EYE_R_OUTER": ('Z', math.radians(12), 'J_Adj_R_FaceEye'),
            "EYE_R_UP": ('X', math.radians(-10), 'J_Adj_R_FaceEye'),
            "EYE_R_DOWN": ('X', math.radians(10), 'J_Adj_R_FaceEye'),
            "EYE_L_INNER": ('Z', math.radians(8), 'J_Adj_L_FaceEye'),
            "EYE_L_OUTER": ('Z', math.radians(-12), 'J_Adj_L_FaceEye'),
            "EYE_L_UP": ('X', math.radians(-10), 'J_Adj_L_FaceEye'),
            "EYE_L_DOWN": ('X', math.radians(10), 'J_Adj_L_FaceEye'),
        }

        # Select the armature and enter pose mode
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects['Armature'].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects['Armature']
        bpy.ops.object.mode_set(mode='POSE')

        # Store the initial pose
        initial_pose = {bone: bone.rotation_euler.copy() for bone in bpy.data.objects['Armature'].pose.bones}

        for shape_key_name, rotation_data in rotations.items():
            axis, angle, *bones = rotation_data

            for bone_name in bones:
                # Select the bone and rotate it
                bpy.data.objects['Armature'].pose.bones[bone_name].rotation_mode = 'XYZ'
                if axis == 'Z':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[2] += angle
                elif axis == 'X':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[0] += angle
                elif axis == 'Y':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[1] += angle

            # Apply the pose as a shape key
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')

            # Select the Face mesh for eye shape keys
            bpy.data.objects['Face'].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects['Face']

            # Apply the armature modifier as a shape key
            bpy.ops.object.modifier_apply_as_shapekey(modifier="Armature")

            # Rename the shape key
            bpy.context.object.data.shape_keys.key_blocks[-1].name = shape_key_name

            # Re-add the armature modifier
            bpy.ops.object.modifier_add(type='ARMATURE')
            bpy.context.object.modifiers["Armature"].object = bpy.data.objects["Armature"]

            # Reset the bone rotation to the initial pose
            bpy.ops.object.select_all(action='DESELECT')
            bpy.data.objects['Armature'].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects['Armature']
            bpy.ops.object.mode_set(mode='POSE')
            for bone in bpy.data.objects['Armature'].pose.bones:
                bone.rotation_euler = initial_pose[bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class CreateBlushingLayerButton(bpy.types.Operator):
    bl_idname = "object.create_blushing_layer"
    bl_label = bpy.app.translations.pgettext("Create Blushing Layer")
    bl_description = bpy.app.translations.pgettext("Creates a transparent blushing layer over the face with blend shapes for Bakin. Provide a 2048x2048 image divided into 4 blocks of 1024x1024px for each blush variation.")

    filepath: bpy.props.StringProperty(subtype="FILE_PATH")

    def execute(self, context):
        image = self.load_image(self.filepath)
        if image is None:
            return {'CANCELLED'}
        image.name = "Blush_0"
        return self.process_blushing_layer(context, image)

    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def load_image(self, filepath):
        if not filepath:
            self.report({'ERROR'}, "No file selected")
            return None
        try:
            image = bpy.data.images.load(filepath)
            return image
        except Exception as e:
            self.report({'ERROR'}, f"Failed to load image: {str(e)}")
            return None

    def process_blushing_layer(self, context, image):
        face_mesh = bpy.data.objects.get('Face')
        if not face_mesh:
            self.report({'ERROR'}, "Face mesh not found.")
            return {'CANCELLED'}

        # Find the material with "Face" and "SKIN" in the name
        face_material = None
        for mat in bpy.data.materials:
            if "Face" in mat.name and "SKIN" in mat.name and "MToon Outline" not in mat.name:
                face_material = mat
                break
        if not face_material:
            self.report({'ERROR'}, "No material with 'Face' and 'SKIN' found. Available materials: " + ", ".join([mat.name for mat in bpy.data.materials]))
            return {'CANCELLED'}

        # Check if the material is assigned to the face mesh
        face_material_index = face_mesh.data.materials.find(face_material.name)
        if face_material_index == -1:
            face_mesh.data.materials.append(face_material)
            face_material_index = face_mesh.data.materials.find(face_material.name)
            self.report({'INFO'}, f"Assigned material {face_material.name} to Face mesh.")

        # Create vertex groups for blushing layers
        for i in range(1, 5):
            group_name = f'Blush_Layer_{i}'
            if group_name not in face_mesh.vertex_groups:
                face_mesh.vertex_groups.new(name=group_name)

        # Enter edit mode
        bpy.context.view_layer.objects.active = face_mesh
        bpy.ops.object.mode_set(mode='EDIT')
        bm = bmesh.from_edit_mesh(face_mesh.data)
        deform_layer = bm.verts.layers.deform.verify()

        # Select faces with the face material
        bpy.ops.mesh.select_all(action='DESELECT')
        selected_faces = 0
        for face in bm.faces:
            if face.material_index == face_material_index:
                face.select = True
                selected_faces += 1

        if selected_faces == 0:
            self.report({'ERROR'}, f"No faces found with material {face_material.name}. Material slots: " + ", ".join([mat.name if mat else "None" for mat in face_mesh.data.materials]))
            return {'CANCELLED'}

        # Calculate centroid of selected geometry
        selected_verts = [v for v in bm.verts if any(f.select for f in v.link_faces)]
        if not selected_verts:
            self.report({'ERROR'}, "No vertices associated with selected faces.")
            return {'CANCELLED'}
        centroid = sum((v.co for v in selected_verts), mathutils.Vector()) / len(selected_verts)

        # Duplicate and process blushing layers
        uv_layer = bm.loops.layers.uv.active
        uv_offsets = [
            (0.0, 0.0),    # Bottom-left block
            (0.5, 0.0),    # Bottom-right block
            (0.0, 0.5),    # Top-left block
            (0.5, 0.5)     # Top-right block
        ]
        normal_positions = {}
        group_vertex_indices = {}
        for i in range(1, 5):
            new_group_name = f'Blush_Layer_{i}'
            new_group = face_mesh.vertex_groups[new_group_name]

            # Reselect faces for duplication
            bpy.ops.mesh.select_all(action='DESELECT')
            for face in bm.faces:
                if face.material_index == face_material_index:
                    face.select = True

            # Duplicate selected faces
            bpy.ops.mesh.duplicate()
            bm = bmesh.from_edit_mesh(face_mesh.data)  # Refresh BMesh
            selected_verts = [v for v in bm.verts if v.select]
            if not selected_verts:
                self.report({'ERROR'}, f"Failed to duplicate vertices for {new_group_name}.")
                return {'CANCELLED'}

            # Scale duplicated vertices around centroid
            scale_factor = 1.02
            for vert in selected_verts:
                vert.co = centroid + (vert.co - centroid) * scale_factor

            # Assign duplicated vertices to new group
            for v in selected_verts:
                v[deform_layer][new_group.index] = 1.0
                normal_positions[(new_group_name, v.index)] = v.co.copy()
                v.co = mathutils.Vector((0, 0, 0))  # Hide by moving to origin

            # Shift UVs for duplicated vertices
            for vert in selected_verts:
                for loop in vert.link_loops:
                    uv = loop[uv_layer].uv
                    uv.x = uv.x * 0.5
                    uv.y = uv.y * 0.5
                    uv.x += uv_offsets[i-1][0]
                    uv.y += uv_offsets[i-1][1]

            group_vertex_indices[new_group_name] = [v.index for v in selected_verts]

        # Create new material for blushing layer
        new_material_name = "BLUSH_LAYER"
        new_material = bpy.data.materials.get(new_material_name)
        if not new_material:
            new_material = face_material.copy()
            new_material.name = new_material_name
            # Set material to transparent
            if hasattr(new_material, 'vrm_addon_extension'):
                vrm_extension = new_material.vrm_addon_extension
                if hasattr(vrm_extension, 'mtoon1'):
                    vrm_extension.mtoon1.alpha_mode = 'BLEND'
                    vrm_extension.mtoon1.pbr_metallic_roughness.base_color_factor[3] = 0.5  # Semi-transparent
                    vrm_extension.mtoon1.pbr_metallic_roughness.base_color_texture.index.source = image
                    # Detach other textures
                    vrm_extension.mtoon1.extensions.vrmc_materials_mtoon.shade_multiply_texture.index.source = None
                    vrm_extension.mtoon1.normal_texture.index.source = None
                    vrm_extension.mtoon1.emissive_texture.index.source = None
                    # Set outline width to 0
                    vrm_extension.mtoon1.extensions.vrmc_materials_mtoon.outline_width_factor = 0
                else:
                    self.report({'WARNING'}, "Could not set VRM material properties.")
            else:
                self.report({'WARNING'}, "VRM material extension not found.")

        if new_material.name not in [mat.name for mat in face_mesh.data.materials]:
            face_mesh.data.materials.append(new_material)
        material_index = face_mesh.data.materials.find(new_material.name)

        # Assign material to duplicated faces
        bpy.ops.mesh.select_all(action='DESELECT')
        for i in range(1, 5):
            new_group = face_mesh.vertex_groups[f'Blush_Layer_{i}']
            face_mesh.vertex_groups.active = new_group
            bpy.ops.object.vertex_group_select()

        bm = bmesh.from_edit_mesh(face_mesh.data)  # Refresh BMesh
        for face in bm.faces:
            if any(vert.select for vert in face.verts):
                face.material_index = material_index

        # Update and exit edit mode
        bmesh.update_edit_mesh(face_mesh.data)
        bpy.ops.object.mode_set(mode='OBJECT')

        # Create shape keys
        if face_mesh.data.shape_keys is None:
            face_mesh.shape_key_add(name="Basis")
        for i in range(1, 5):
            shape_key = face_mesh.shape_key_add(name=f"BLUSH_{i}")
            new_group_name = f'Blush_Layer_{i}'
            alt_vertices = group_vertex_indices[new_group_name]
            for vert_index in alt_vertices:
                shape_key.data[vert_index].co = normal_positions[(new_group_name, vert_index)]

        self.report({'INFO'}, "Blushing layer created successfully.")
        return {'FINISHED'}



class AddHeadBodyShapeKeysButton(bpy.types.Operator):
    bl_idname = "object.add_head_body_shape_keys"
    bl_label = bpy.app.translations.pgettext("Add Head + Body Shape Keys")
    bl_description = bpy.app.translations.pgettext("Adds Shape Keys for head tilt/rotation and body movement. This will let you pose the head and body in real time using BAKIN's Blend Shapes.")

    def execute(self, context):
        # Define the rotations for head shape keys
        head_rotations = {
            "HAIR_UP": ('X', math.radians(-30), 'J_Bip_C_Head'),
            "HAIR_DOWN": ('X', math.radians(30), 'J_Bip_C_Head'),
            "HAIR_LEFT": ('Y', math.radians(-30), 'J_Bip_C_Head'),
            "HAIR_RIGHT": ('Y', math.radians(30), 'J_Bip_C_Head'),
            "HAIR_TILT_LEFT": ('Z', math.radians(30), 'J_Bip_C_Head'),
            "HAIR_TILT_RIGHT": ('Z', math.radians(-30), 'J_Bip_C_Head'),
            "HEAD_UP": ('X', math.radians(-30), 'J_Bip_C_Head'),
            "HEAD_DOWN": ('X', math.radians(30), 'J_Bip_C_Head'),
            "HEAD_LEFT": ('Y', math.radians(-30), 'J_Bip_C_Head'),
            "HEAD_RIGHT": ('Y', math.radians(30), 'J_Bip_C_Head'),
            "HEAD_TILT_LEFT": ('Z', math.radians(30), 'J_Bip_C_Head'),
            "HEAD_TILT_RIGHT": ('Z', math.radians(-30), 'J_Bip_C_Head'),
        }

        # Define the body shape keys
        body_rotations = {
            "BODY_UP": ('X', math.radians(-30), 'J_Bip_C_Head'),
            "BODY_DOWN": ('X', math.radians(30), 'J_Bip_C_Head'),
            "BODY_LEFT": ('Y', math.radians(-30), 'J_Bip_C_Head'),
            "BODY_RIGHT": ('Y', math.radians(30), 'J_Bip_C_Head'),
            "BODY_TILT_LEFT": ('Z', math.radians(30), 'J_Bip_C_Head'),
            "BODY_TILT_RIGHT": ('Z', math.radians(-30), 'J_Bip_C_Head'),
        }

        # Select the armature and enter pose mode
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects['Armature'].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects['Armature']
        bpy.ops.object.mode_set(mode='POSE')

        # Store the initial pose
        initial_pose = {bone: bone.rotation_euler.copy() for bone in bpy.data.objects['Armature'].pose.bones}

        # Find the hair and face meshes
        hair_mesh = None
        face_mesh = None
        for obj in bpy.data.objects:
            if "Hair" in obj.name and obj.type == 'MESH':
                hair_mesh = obj
            if "Face" in obj.name and obj.type == 'MESH':
                face_mesh = obj

        # Process head (hair, face, and head) shape keys
        for shape_key_name, rotation_data in head_rotations.items():
            axis, angle, *bones = rotation_data

            for bone_name in bones:
                # Select the bone and rotate it
                bpy.data.objects['Armature'].pose.bones[bone_name].rotation_mode = 'XYZ'
                if axis == 'Z':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[2] += angle
                elif axis == 'X':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[0] += angle
                elif axis == 'Y':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[1] += angle

            # Apply the pose as a shape key
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')

            # Apply to appropriate mesh based on shape key prefix
            if "HAIR" in shape_key_name and hair_mesh:
                hair_mesh.select_set(True)
                bpy.context.view_layer.objects.active = hair_mesh
            elif "HEAD" in shape_key_name and face_mesh:
                face_mesh.select_set(True)
                bpy.context.view_layer.objects.active = face_mesh
            else:
                bpy.data.objects['Body'].select_set(True)
                bpy.context.view_layer.objects.active = bpy.data.objects['Body']

            # Apply the armature modifier as a shape key
            bpy.ops.object.modifier_apply_as_shapekey(modifier="Armature")

            # Rename the shape key
            bpy.context.object.data.shape_keys.key_blocks[-1].name = shape_key_name

            # Re-add the armature modifier
            bpy.ops.object.modifier_add(type='ARMATURE')
            bpy.context.object.modifiers["Armature"].object = bpy.data.objects["Armature"]

            # Reset the bone rotation to the initial pose
            bpy.ops.object.select_all(action='DESELECT')
            bpy.data.objects['Armature'].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects['Armature']
            bpy.ops.object.mode_set(mode='POSE')
            for bone in bpy.data.objects['Armature'].pose.bones:
                bone.rotation_euler = initial_pose[bone]

        # Process body shape keys
        for shape_key_name, rotation_data in body_rotations.items():
            axis, angle, *bones = rotation_data

            for bone_name in bones:
                # Select the bone and rotate it
                bpy.data.objects['Armature'].pose.bones[bone_name].rotation_mode = 'XYZ'
                if axis == 'Z':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[2] += angle
                elif axis == 'X':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[0] += angle
                elif axis == 'Y':
                    bpy.data.objects['Armature'].pose.bones[bone_name].rotation_euler[1] += angle

            # Apply the pose as a shape key on the Body mesh
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')
            bpy.data.objects['Body'].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects['Body']
            bpy.ops.object.modifier_apply_as_shapekey(modifier="Armature")

            # Rename the shape key
            bpy.context.object.data.shape_keys.key_blocks[-1].name = shape_key_name

            # Re-add the armature modifier
            bpy.ops.object.modifier_add(type='ARMATURE')
            bpy.context.object.modifiers["Armature"].object = bpy.data.objects["Armature"]

            # Reset the bone rotation to the initial pose
            bpy.ops.object.select_all(action='DESELECT')
            bpy.data.objects['Armature'].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects['Armature']
            bpy.ops.object.mode_set(mode='POSE')
            for bone in bpy.data.objects['Armature'].pose.bones:
                bone.rotation_euler = initial_pose[bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}


class ExportFBXUnifiedButton(bpy.types.Operator):
    bl_idname = "object.export_fbx_unified"
    bl_label = bpy.app.translations.pgettext("Export FBX + DEF (Unified)")
    bl_description = bpy.app.translations.pgettext("Exports the FBX model, textures, and DEF file for RPG Developer BAKIN. Choose material type for export based on the 'Materials Reduced' setting you've exported the model from VRoid Studio: 8 or 2 materials, or without Materials Reduced.")

    material_count: bpy.props.EnumProperty(
        name="Material Type",
        items=[
            ('8', "8 Materials", "Export FBX and DEF with 8 materials"),
            ('2', "2 Materials", "Export FBX and DEF with 2 materials"),
            ('unrestricted', "Unlimited", "Export FBX and DEF with all materials (unrestricted)")
        ],
        default='8'
    )
    
    # Add Accurate Shadows &/OR Body Outlines tickbox
    accurate_shadows_body_outlines: bpy.props.BoolProperty(
        name="Accurate Shadows &/OR Body Outlines",
        description="Using outlines, or want more accurate shadows? Enable this, as it'll make outlines usable and will cast shadows. This reduces graphical fidelity. Only on 8 or Unlimited Material modes.",
        default=True
    )
    
    use_new_vrm_shader: bpy.props.BoolProperty(
        name="Use Official VRM Shader",
        description="Enable to use the new VRM shader that directly imported VRMs use in Bakin, using VRM or VRM0 depending on the model. Turn off to use the original Toon shader.",
        default=True
    )

    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        layout = self.layout
        layout.prop(self, "material_count", expand=True)
        
        # Show or grey out the checkbox based on selected material type
        if self.material_count in {'8', 'unrestricted'}:
            layout.prop(self, "accurate_shadows_body_outlines")
        else:
            layout.label(text="Accurate Shadows &/OR Body Outlines (Only for 8/Unlimited Modes)", icon="INFO")
            
        
        layout.prop(self, "use_new_vrm_shader")

        layout.label(text="Configure the export settings and click OK to proceed.")

    def execute(self, context):
        try:
            material_count = self.material_count
            accurate_shadows = self.accurate_shadows_body_outlines
            my_new_vrm_shader = self.accurate_shadows_body_outlines
            self.export_fbx(context, material_count, accurate_shadows, my_new_vrm_shader)
        except Exception as e:
            self.report({'ERROR'}, f"Failed to export FBX: {e}")
            return {'CANCELLED'}
        return {'FINISHED'}

    def export_fbx(self, context, material_count, accurate_shadows_body_outlines, my_new_vrm_shader):
        is_vrm_10 = (bpy.data.objects['Armature'].data.vrm_addon_extension.spec_version == "1.0")
        
        if is_vrm_10:
            vrm_model_name = bpy.data.objects['Armature'].data.vrm_addon_extension.vrm1.meta['vrm_name'].replace(' ', '_')
        else:
            vrm_model_name = bpy.data.objects['Armature'].data.vrm_addon_extension.vrm0.meta.title.replace(' ', '_')
        
        # Sanitize the VRM model name
        vrm_model_name = re.sub(r'[<>:"/\\|?*\t\n\r]', '_', vrm_model_name)

        dirpath = bpy.path.abspath("//" + vrm_model_name + " (BakinVRM)")
        os.makedirs(dirpath, exist_ok=True)

        for image in bpy.data.images:
            if not image.has_data or image.type != 'IMAGE':
                continue
            new_image_name = vrm_model_name + "_" + image.name
            image.save_render(os.path.join(dirpath, new_image_name + ".png"))

        filepath = os.path.join(dirpath, vrm_model_name + ".fbx")
        bpy.ops.export_scene.fbx(
            filepath=filepath,
            use_selection=False,
            global_scale=0.01,
            use_mesh_modifiers=False,
            add_leaf_bones=False,
            use_tspace=True
        )
        
        
        shader_line = "shader toon c3a93e68844545618e04eb31f52898c8"  # Default shader

        if my_new_vrm_shader:
            if is_vrm_10:
                shader_line = "shader toonVRM cd4f425e2e9689db5dcd906708975e0c"
            else:
                shader_line = "shader toonVRM0X A8FC73041E11648931FD007D67C5DB6A"

        meshes = [obj for obj in bpy.data.objects if obj.type == 'MESH']
        single_body_mesh = 'Face' not in meshes and 'Hair' not in meshes
        print(f"Single body mesh detected: {single_body_mesh}")  # Debug statement

        with open(os.path.join(dirpath, vrm_model_name + ".def"), 'w') as f:
            materials_in_use = set()
            mesh_materials = {'Face': set(), 'Body': set(), 'Hair': set()}

            for obj in bpy.data.objects:
                if obj.type == 'MESH' and obj.name in mesh_materials:
                    for mat_slot in obj.material_slots:
                        if mat_slot.material:
                            materials_in_use.add(mat_slot.material)
                            mesh_materials[obj.name].add(mat_slot.material)

            for mat in materials_in_use:
                f.write(f'mtl {mat.name}\n')
                f.write(shader_line + "\n")
                f.write('emissiveBlink false\n')
                f.write('emissiveBlinkSpeed 0.000000\n')
                f.write('emissiveLinkBuildingLight false\n')
                f.write('uscrollanim false\n')
                f.write('vscrollanim false\n')
                f.write('scrollanimspeed 0.000000 0.000000\n')
                f.write('uvstepanim false\n')
                f.write('uvstepanimparam 1 1 0 1.000000\n')
                f.write('sortindex 0\n')
                f.write('castshadow true\n')


                gltf = mat.vrm_addon_extension.mtoon1
                mtoon = gltf.extensions.vrmc_materials_mtoon
                outline_width = round(mtoon.outline_width_factor, 3)
                
                material_name_upper = mat.name.upper()

                if outline_width > 0:
                    if "EYE_ALTERNATIVE_IRISES" in material_name_upper:
                        f.write('drawOutline false\n')
                    else:
                        f.write('drawOutline true\n')
                else:
                    f.write('drawOutline false\n')
                    
                f.write(f'outlineWidth {outline_width}\n')

                outline_color = mtoon.outline_color_factor
                f.write(f'outlineColor {outline_color[0]:.6f} {outline_color[1]:.6f} {outline_color[2]:.6f} 1.000000\n')
                
                f.write('overrideOutlineSetting true\n')
                
                f.write('outlineType World\n')
                f.write('outlineMaxScale 1.000000\n')
                f.write('outlineMixLighting 0.000000\n')

                f.write('distanceFade false\n')
                f.write('uvofs 0.000000 0.000000\n')
                f.write('uvscl 1.000000 1.000000\n')
                
                print(f"Processing material: {mat.name}, Single body mesh: {single_body_mesh}")  # Debug statement

                if material_count == '8' or material_count == 'unrestricted':
                    if "CLOTH" in material_name_upper and accurate_shadows_body_outlines:
                        f.write('RenderingType Cutoff\n')
                        f.write('cutOffThreshold 0.600000\n')
                    elif "EYE" in material_name_upper or "CLOTH" in material_name_upper:
                        f.write('RenderingType TranslucentWithDepth\n')
                        f.write('cutOffThreshold 0.005000\n')
                    else:
                        f.write('RenderingType Cutoff\n')
                        f.write('cutOffThreshold 0.600000\n')

                    if "CLOTH" in material_name_upper:
                        f.write('cull none\n')
                    else:
                        f.write('cull back\n')

                    if "EYE_ALTERNATIVE_IRISES" in material_name_upper:
                            f.write(f'LitMap {vrm_model_name}_{self.get_litmap_name(mat)}.png\n')
                            f.write(f'ShadeMap {vrm_model_name}_Image_7.png\n')
                            f.write(f'NormalMap {vrm_model_name}_Image_2.png\n')
                            f.write(f'EmiMap {vrm_model_name}_Image_1.png\n')
                            f.write(f'outlineWeight {vrm_model_name}_Image_9.png\n')
                    elif single_body_mesh:
                        if "FACE" in material_name_upper or "EYE" in material_name_upper:
                            print(f"Using face/eye textures for material: {mat.name} (SINGLE BODY FOUND)")  # Debug statement
                            f.write(f'LitMap {vrm_model_name}_Image_0.png\n')
                            f.write(f'ShadeMap {vrm_model_name}_Image_7.png\n')
                            f.write(f'NormalMap {vrm_model_name}_Image_2.png\n')
                            f.write(f'EmiMap {vrm_model_name}_Image_1.png\n')
                            f.write(f'outlineWeight {vrm_model_name}_Image_9.png\n')
                        else:
                            print(f"Using body textures for material: {mat.name} (SINGLE BODY FOUND)")  # Debug statement
                            f.write(f'LitMap {vrm_model_name}_Image_3.png\n')
                            f.write(f'ShadeMap {vrm_model_name}_Image_10.png\n')
                            f.write(f'NormalMap {vrm_model_name}_Image_5.png\n')
                            f.write(f'EmiMap {vrm_model_name}_Image_4.png\n')
                            f.write(f'outlineWeight {vrm_model_name}_Image_11.png\n')
                    else:
                        if mat in mesh_materials['Hair'] or mat in mesh_materials['Body']:
                            print(f"Using body textures for material: {mat.name} (MULTI BODY FOUND)")  # Debug statement
                            f.write(f'LitMap {vrm_model_name}_Image_3.png\n')
                            f.write(f'ShadeMap {vrm_model_name}_Image_10.png\n')
                            f.write(f'NormalMap {vrm_model_name}_Image_5.png\n')
                            f.write(f'EmiMap {vrm_model_name}_Image_4.png\n')
                            f.write(f'outlineWeight {vrm_model_name}_Image_11.png\n')
                        elif mat in mesh_materials['Face']:
                            print(f"Using face/eye textures for material: {mat.name} (MULTI BODY FOUND)")  # Debug statement
                            f.write(f'LitMap {vrm_model_name}_Image_0.png\n')
                            f.write(f'ShadeMap {vrm_model_name}_Image_7.png\n')
                            f.write(f'NormalMap {vrm_model_name}_Image_2.png\n')
                            f.write(f'EmiMap {vrm_model_name}_Image_1.png\n')
                            f.write(f'outlineWeight {vrm_model_name}_Image_9.png\n')

                elif material_count == '2':
                    f.write('RenderingType Cutoff\n')
                    f.write('cutOffThreshold 0.600000\n')
                    f.write('cull back\n')

                    if "EYE_ALTERNATIVE_IRISES" in material_name_upper:
                        f.write(f'LitMap {vrm_model_name}_{self.get_litmap_name(mat)}.png\n')
                        f.write(f'ShadeMap {vrm_model_name}_Image_7.png\n')
                        f.write(f'NormalMap {vrm_model_name}_Image_2.png\n')
                        f.write(f'EmiMap {vrm_model_name}_Image_1.png\n')
                        f.write(f'outlineWeight {vrm_model_name}_Image_9.png\n')
                    elif mat in mesh_materials['Hair'] or mat in mesh_materials['Body']:
                        f.write(f'LitMap {vrm_model_name}_Image_3.png\n')
                        f.write(f'ShadeMap {vrm_model_name}_Image_10.png\n')
                        f.write(f'NormalMap {vrm_model_name}_Image_5.png\n')
                        f.write(f'EmiMap {vrm_model_name}_Image_4.png\n')
                        f.write(f'outlineWeight {vrm_model_name}_Image_11.png\n')
                    elif mat in mesh_materials['Face']:
                        f.write(f'LitMap {vrm_model_name}_Image_0.png\n')
                        f.write(f'ShadeMap {vrm_model_name}_Image_7.png\n')
                        f.write(f'NormalMap {vrm_model_name}_Image_2.png\n')
                        f.write(f'EmiMap {vrm_model_name}_Image_1.png\n')
                        f.write(f'outlineWeight {vrm_model_name}_Image_9.png\n')

                f.write('LitColor 1.000000 1.000000 1.000000 1.000000\n')
                f.write('ShadeColor 0.600000 0.600000 0.600000 1.000000\n')
                f.write('normalscl 1.000000\n')
                f.write('toony 0.900000\n')
                f.write('shift 0.000000\n')
                f.write('LitShaderMixTexMult 0.000000\n')
                f.write('lightColorAtt 0.000000\n')
                f.write('Emission 1.000000 1.000000 1.000000\n')
                f.write('EmissionInt 1.000000\n')
                f.write('MCMap MatcapWarp.png\n')
                f.write('matCapScale 1.000000\n')
                f.write('Rim 0.000000 0.000000 0.000000\n')
                f.write('RimInt 1.000000\n')
                f.write('RimLightingMix 0.000000\n')
                f.write('RimFresnelPow 0.000000\n')
                f.write('RimLift 0.000000\n')
                f.write('UVRotateAnimation 0.000000\n')
                f.write('\n')

    def get_litmap_name(self, mat):
        gltf = mat.vrm_addon_extension.mtoon1
        return gltf.pbr_metallic_roughness.base_color_texture.index.source.name
    
    def get_shademap_name(self, mat):
        gltf = mat.vrm_addon_extension.mtoon1
        mtoon = gltf.extensions.vrmc_materials_mtoon
        return mtoon.shade_multiply_texture.index.source.name
    
    def get_normalmap_name(self, mat):
        gltf = mat.vrm_addon_extension.mtoon1
        return gltf.normal_texture.index.source.name
    
    def get_emimap_name(self, mat):
        gltf = mat.vrm_addon_extension.mtoon1
        return gltf.emissive_texture.index.source.name

class ImportVRMButton(bpy.types.Operator):
    bl_idname = "object.import_vrm"
    bl_label = bpy.app.translations.pgettext("Import VRM")
    bl_description = bpy.app.translations.pgettext("Import the VRM model into Blender. You need to have the VRM addon for Blender for this to work. This is the same as doing the Import from the File menu. There is no need to enable Texture export, as the export on this addon will handle everything.")
    filepath: bpy.props.StringProperty(subtype="FILE_PATH")

    def execute(self, context):
        try:
            bpy.ops.import_scene.vrm('INVOKE_DEFAULT')
            context.scene.render.fps = 60
            print("Imported VRM file from: ", self.filepath)  # Print the filepath

            # Delete any image from the scene that doesn't start with either "Image_", "Matcap" or "Thumbnail"
            for image in bpy.data.images:
                if not image.name.startswith(("Image_", "Matcap", "Thumbnail")):
                    bpy.data.images.remove(image)

        except Exception as e:
            print("Failed to import VRM: ", e)

        return {'FINISHED'}
    
class FusionAndAddBonusesButton(bpy.types.Operator):
    bl_idname = "object.fusion_and_add_bonuses"
    bl_label = bpy.app.translations.pgettext("Fusion Meshes and Hair/Head Keys")
    bl_description = bpy.app.translations.pgettext("Strongly recommended (8 materials / unlimited materials only). Merges available meshes (Body, Face, Hair) together and merges both head and hair shape keys into a new Head shapekey that handles both at once!")

    def execute(self, context):
        # Find available meshes (Body, Face, and any Hair meshes)
        hair_objects = [obj for obj in bpy.data.objects if "Hair" in obj.name and obj.type == 'MESH']
        body = bpy.data.objects.get("Body")
        face = bpy.data.objects.get("Face")

        # Collect all valid meshes
        available_meshes = []
        if body:
            available_meshes.append(body)
        if face:
            available_meshes.append(face)
        available_meshes.extend(hair_objects)

        # Check if at least two meshes are present
        if len(available_meshes) < 2:
            self.report({'ERROR'}, "At least two meshes (Body, Face, or Hair) are required for fusion.")
            return {'CANCELLED'}

        # Dictionary to store the outline_width_mode values
        outline_width_mode_values = {}

        # Function to store outline_width_mode before merge
        def store_outline_width_mode(obj):
            for mat_slot in obj.material_slots:
                if mat_slot.material is not None:
                    material = mat_slot.material
                    try:
                        outline_width_mode = material.vrm_addon_extension.mtoon1.extensions.vrmc_materials_mtoon.outline_width_mode
                        outline_width_mode_values[material.name] = outline_width_mode
                    except AttributeError:
                        pass

        # Store outline_width_mode for all available meshes
        for mesh in available_meshes:
            store_outline_width_mode(mesh)

        # Select the first available mesh as the base for joining
        bpy.ops.object.select_all(action='DESELECT')
        base_mesh = available_meshes[0]
        base_mesh.select_set(True)
        bpy.context.view_layer.objects.active = base_mesh
        bpy.ops.object.mode_set(mode='OBJECT')

        # Join all other meshes into the base mesh
        for mesh in available_meshes[1:]:
            mesh.select_set(True)
        if len(available_meshes) > 1:
            bpy.ops.object.join()

        # Get the merged object
        merged_obj = bpy.context.active_object
        merged_obj.name = "Body"  # Rename to Body for consistency

        # Reassign the outline_width_mode to the merged object's materials
        for mat_slot in merged_obj.material_slots:
            if mat_slot.material is not None:
                material = mat_slot.material
                if material.name in outline_width_mode_values:
                    try:
                        material.vrm_addon_extension.mtoon1.extensions.vrmc_materials_mtoon.outline_width_mode = outline_width_mode_values[material.name]
                    except AttributeError:
                        pass

        # Push the current state to the undo stack
        bpy.ops.ed.undo_push(message="Fusion Meshes and Hair/Head Keys")

        # Ensure the shape keys exist
        if merged_obj.data.shape_keys is None:
            bpy.ops.object.shape_key_add()

        shape_keys = merged_obj.data.shape_keys
        if shape_keys is None:
            self.report({'ERROR'}, "Shape keys not found in the merged object.")
            return {'CANCELLED'}

        # Find pairs of HEAD_, HAIR_, and BODY_ shape keys
        head_keys = {key.name: key for key in shape_keys.key_blocks if key.name.startswith("HEAD_")}
        hair_keys = {key.name: key for key in shape_keys.key_blocks if key.name.startswith("HAIR_")}
        body_keys = {key.name: key for key in shape_keys.key_blocks if key.name.startswith("BODY_")}

        # Ensure the vertex group exists
        if "J_Bip_C_Head" not in merged_obj.vertex_groups:
            self.report({'ERROR'}, "Vertex group 'J_Bip_C_Head' not found in the merged object.")
            return {'CANCELLED'}

        head_vertex_group = merged_obj.vertex_groups["J_Bip_C_Head"]

        # Combine shape keys where possible
        for head_key_name, head_key in head_keys.items():
            corresponding_hair_key_name = head_key_name.replace("HEAD_", "HAIR_")
            corresponding_body_key_name = head_key_name.replace("HEAD_", "BODY_")
            itemlook_name = "HEAD_" + head_key_name.replace("HEAD_", "")

            # Create a new shape key for ITEMLOOK
            bpy.ops.object.shape_key_add()
            new_key = shape_keys.key_blocks[-1]
            new_key.name = itemlook_name

            # Apply changes from available shape keys
            for vertex_index in range(len(merged_obj.data.vertices)):
                base_vertex = shape_keys.key_blocks[0].data[vertex_index].co
                new_vertex_position = base_vertex.copy()

                # Add HEAD_ contribution
                head_vertex = head_key.data[vertex_index].co
                new_vertex_position += (head_vertex - base_vertex)

                # Add HAIR_ contribution if available
                if corresponding_hair_key_name in hair_keys:
                    hair_vertex = hair_keys[corresponding_hair_key_name].data[vertex_index].co
                    new_vertex_position += (hair_vertex - base_vertex)

                # Add BODY_ contribution if available
                if corresponding_body_key_name in body_keys:
                    body_vertex = body_keys[corresponding_body_key_name].data[vertex_index].co
                    new_vertex_position += (body_vertex - base_vertex)

                # Apply the new position to the shape key
                new_key.data[vertex_index].co = new_vertex_position

            # Ensure the new shape key is within the 0.0 to 1.0 range
            new_key.value = min(new_key.value, 1.0)

        # Delete the original HEAD_, HAIR_, and BODY_ shape keys
        for head_key_name in list(head_keys.keys()):
            bpy.context.object.active_shape_key_index = bpy.context.object.data.shape_keys.key_blocks.keys().index(head_key_name)
            bpy.ops.object.shape_key_remove()

        for hair_key_name in list(hair_keys.keys()):
            bpy.context.object.active_shape_key_index = bpy.context.object.data.shape_keys.key_blocks.keys().index(hair_key_name)
            bpy.ops.object.shape_key_remove()

        for body_key_name in list(body_keys.keys()):
            bpy.context.object.active_shape_key_index = bpy.context.object.data.shape_keys.key_blocks.keys().index(body_key_name)
            bpy.ops.object.shape_key_remove()

        # Remove ".001" suffix from HEAD_ shape key names
        for key in shape_keys.key_blocks:
            if key.name.startswith("HEAD_") and ".001" in key.name:
                new_name = key.name.replace(".001", "")
                key.name = new_name

        # Report if only two meshes were fused
        if len(available_meshes) == 2:
            self.report({'INFO'}, "Only two meshes were found and fused.")

        bpy.ops.object.mode_set(mode='OBJECT')
        return {'FINISHED'}


class CreateAlternateIrisesButton(bpy.types.Operator):
    bl_idname = "object.create_alternate_irises"
    bl_label = bpy.app.translations.pgettext("Create Alternate Irises")
    bl_description = bpy.app.translations.pgettext("Creates alternative irises that can be displayed as emotions through blend shapes in Bakin! IMPORTANT: Provide it with a 4096x4096 image. The image is divided into 4 blocks of 2048x2048px, and within each block, the irises are situated in the bottom half, with the eye highlights in the top half of each section. Try out the template image on the github!")

    filepath: bpy.props.StringProperty(subtype="FILE_PATH")

    def execute(self, context):
        image = self.load_image(self.filepath)
        if image is None:
            return {'CANCELLED'}
        image.name = "Irises_0"
        return self.process_irises(context, image)

    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def load_image(self, filepath):
        if not filepath:
            self.report({'ERROR'}, "No file selected")
            return None
        try:
            image = bpy.data.images.load(filepath)
            return image
        except Exception as e:
            self.report({'ERROR'}, f"Failed to load image: {str(e)}")
            return None

    def process_irises(self, context, image):
        face_mesh = bpy.data.objects.get('Face')
        armature = bpy.data.objects.get('Armature')
        if not face_mesh or not armature:
            self.report({'ERROR'}, "Required objects not found.")
            return {'CANCELLED'}
        
        # Create vertex groups for alternate irises
        for side in ['L', 'R']:
            for i in range(1, 5):
                group_name = f'J_Adj_{side}_FaceEyeAlt{i}'
                if group_name not in face_mesh.vertex_groups:
                    face_mesh.vertex_groups.new(name=group_name)
        
        # Enter edit mode
        bpy.context.view_layer.objects.active = face_mesh
        bpy.ops.object.mode_set(mode='EDIT')
        bm = bmesh.from_edit_mesh(face_mesh.data)
        deform_layer = bm.verts.layers.deform.verify()
        
        # Calculate eye centers
        eye_centers = {}
        for side in ['L', 'R']:
            base_group_name = f'J_Adj_{side}_FaceEye'
            base_group = face_mesh.vertex_groups.get(base_group_name)
            if base_group:
                base_vertices = [v for v in bm.verts if base_group.index in v[deform_layer]]
                if base_vertices:
                    center = sum((v.co for v in base_vertices), mathutils.Vector()) / len(base_vertices)
                    eye_centers[side] = center
                else:
                    self.report({'ERROR'}, f"No vertices found in {base_group_name} group.")
                    return {'CANCELLED'}
        
        # Store positions and indices
        normal_positions = {}
        group_vertex_indices = {}
        for side in ['L', 'R']:
            base_group_name = f'J_Adj_{side}_FaceEye'
            base_group = face_mesh.vertex_groups[base_group_name]
            group_vertex_indices[base_group_name] = [v.index for v in bm.verts if base_group.index in v[deform_layer]]
        
        # Duplicate and process alternate irises
        uv_layer = bm.loops.layers.uv.active
        # Texture is 4096x4096, divided into 4 blocks of 2048x2048
        # Each block: top half (highlights), bottom half (iris)
        # UV offsets should map to bottom half of each block
        uv_offsets = [
            (0.0, 0.0),    # Bottom-left block (0,0 to 0.5,0.5)
            (0.5, 0.0),    # Bottom-right block (0.5,0 to 1,0.5)
            (0.0, 0.5),    # Top-left block (0,0.5 to 0.5,1)
            (0.5, 0.5)     # Top-right block (0.5,0.5 to 1,1)
        ]
        for i in range(1, 5):
            for side in ['L', 'R']:
                new_group_name = f'J_Adj_{side}_FaceEyeAlt{i}'
                base_group_name = f'J_Adj_{side}_FaceEye'
                base_group = face_mesh.vertex_groups[base_group_name]
                new_group = face_mesh.vertex_groups[new_group_name]
                
                # Select base group vertices
                bpy.ops.mesh.select_all(action='DESELECT')
                face_mesh.vertex_groups.active = base_group
                bpy.ops.object.vertex_group_select()
                
                # Duplicate selected vertices
                bpy.ops.mesh.duplicate()
                
                # Get duplicated vertices
                bm = bmesh.from_edit_mesh(face_mesh.data)  # Refresh BMesh
                selected_verts = [v for v in bm.verts if v.select]
                if not selected_verts:
                    self.report({'ERROR'}, f"Failed to duplicate vertices for {new_group_name}.")
                    return {'CANCELLED'}
                
                # Assign duplicated vertices to new group and remove from base group
                for v in selected_verts:
                    v[deform_layer][new_group.index] = 1.0
                    if base_group.index in v[deform_layer]:
                        del v[deform_layer][base_group.index]
                    normal_positions[(new_group_name, v.index)] = v.co.copy()
                    v.co = eye_centers[side]
                
                # Shift UVs for duplicated vertices
                for vert in selected_verts:
                    for loop in vert.link_loops:
                        # Original UV range is [0,1] for the entire face texture
                        # We need to scale and offset to map to the bottom half of the 2048x2048 block
                        # Bottom half of a block: Y from 0 to 0.5 (in texture space, 0 to 0.25 in 4096x4096)
                        uv = loop[uv_layer].uv
                        # Scale UVs to fit within a 2048x2048 block (0.5x0.5 in UV space)
                        uv.x = uv.x * 0.5
                        uv.y = uv.y * 0.25
                        # Offset to the correct block
                        uv.x += uv_offsets[i-1][0]
                        uv.y += uv_offsets[i-1][1]
                
                group_vertex_indices[new_group_name] = [v.index for v in selected_verts]
        
        # Assign material to duplicated faces
        new_material_name = "EYE_ALTERNATIVE_IRISES"
        new_material = bpy.data.materials.get(new_material_name)
        if not new_material:
            original_material = bpy.data.materials.get("N00_000_00_FaceMouth_00_FACE (Instance)")
            if original_material:
                new_material = original_material.copy()
                new_material.name = new_material_name
            else:
                self.report({'ERROR'}, "Original material not found.")
                return {'CANCELLED'}
        if new_material.name not in [mat.name for mat in face_mesh.data.materials]:
            face_mesh.data.materials.append(new_material)
        material_index = face_mesh.data.materials.find(new_material.name)
        
        # Update material for faces containing alternate iris vertices
        bpy.ops.mesh.select_all(action='DESELECT')
        for side in ['L', 'R']:
            for i in range(1, 5):
                new_group = face_mesh.vertex_groups[f'J_Adj_{side}_FaceEyeAlt{i}']
                face_mesh.vertex_groups.active = new_group
                bpy.ops.object.vertex_group_select()
        bm = bmesh.from_edit_mesh(face_mesh.data)  # Refresh BMesh
        for face in bm.faces:
            if any(vert.select for vert in face.verts):
                face.material_index = material_index
        
        # Apply texture to material
        if hasattr(new_material, 'vrm_addon_extension'):
            vrm_extension = new_material.vrm_addon_extension
            if hasattr(vrm_extension, 'mtoon1') and hasattr(vrm_extension.mtoon1, 'pbr_metallic_roughness'):
                vrm_extension.mtoon1.pbr_metallic_roughness.base_color_texture.index.source = image
            else:
                self.report({'WARNING'}, "Could not set texture in VRM extension.")
        
        # Update and exit edit mode
        bmesh.update_edit_mesh(face_mesh.data)
        bpy.ops.object.mode_set(mode='OBJECT')
        
        # Create shape keys
        if face_mesh.data.shape_keys is None:
            face_mesh.shape_key_add(name="Basis")
        for i in range(1, 5):
            shape_key = face_mesh.shape_key_add(name=f"ALTERNATE_IRIS_{i}")
            for side in ['L', 'R']:
                alt_group_name = f'J_Adj_{side}_FaceEyeAlt{i}'
                base_group_name = f'J_Adj_{side}_FaceEye'
                alt_vertices = group_vertex_indices[alt_group_name]
                base_vertices = group_vertex_indices[base_group_name]
                for vert_index in alt_vertices:
                    shape_key.data[vert_index].co = normal_positions[(alt_group_name, vert_index)]
                for vert_index in base_vertices:
                    shape_key.data[vert_index].co = eye_centers[side]
        
        # Create bones
        bpy.context.view_layer.objects.active = armature
        bpy.ops.object.mode_set(mode='EDIT')
        for side in ['L', 'R']:
            base_bone_name = f'J_Adj_{side}_FaceEye'
            base_bone = armature.data.edit_bones.get(base_bone_name)
            if base_bone:
                for i in range(1, 5):
                    new_bone_name = f'J_Adj_{side}_FaceEyeAlt{i}'
                    if new_bone_name not in armature.data.edit_bones:
                        new_bone = armature.data.edit_bones.new(name=new_bone_name)
                        new_bone.head = base_bone.head
                        new_bone.tail = base_bone.tail
                        new_bone.parent = base_bone
        bpy.ops.object.mode_set(mode='OBJECT')
        return {'FINISHED'}



def move_vertices_in_group(bm, mesh_obj, group_index, translation_vector):
    """
    This function translates all vertices belonging to a given vertex group
    using bmesh for more control over the vertex manipulation.
    """
    deform_layer = bm.verts.layers.deform.verify()
    
    for vert in bm.verts:
        # Check if the vertex is in the specified vertex group
        if group_index in vert[deform_layer]:
            # Apply the translation to the vertex
            vert.co.x += translation_vector[0]
            vert.co.y += translation_vector[1]
            vert.co.z += translation_vector[2]




    
class ExtractGlassesButton(bpy.types.Operator):
    bl_idname = "object.extract_glasses"
    bl_label = bpy.app.translations.pgettext("Eyewear Only: Split, Export & Delete")
    bl_description = bpy.app.translations.pgettext("Isolates glasses from the VRM model, cleans up materials and shape keys, and optionally exports and deletes them.")

    def execute(self, context):
        # Check if the .blend file is saved
        if not bpy.data.filepath:
            self.report({'ERROR'}, "Please save the .blend file before running this operation.")
            return {'CANCELLED'}

        obj = bpy.context.object
        
        if obj is None or obj.type != 'MESH':
            self.report({'ERROR'}, "No mesh object selected.")
            return {'CANCELLED'}

        # Ensure we're in Object mode
        bpy.ops.object.mode_set(mode='OBJECT')

        # Get vertex groups containing 'glasses'
        glasses_groups = [vgroup for vgroup in obj.vertex_groups if 'glasses' in vgroup.name.lower()]
        
        if not glasses_groups:
            self.report({'WARNING'}, "No vertex groups containing 'glasses' found.")
            return {'CANCELLED'}

        # Switch to Edit mode to select vertices
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.select_all(action='DESELECT')
        
        # Select vertices in glasses vertex groups
        for vgroup in glasses_groups:
            obj.vertex_groups.active = vgroup
            bpy.ops.object.vertex_group_select()

        # Separate selected vertices into a new object
        bpy.ops.mesh.separate(type='SELECTED')

        # Switch back to Object mode
        bpy.ops.object.mode_set(mode='OBJECT')

        # Rename the new object
        new_obj = bpy.context.selected_objects[-1]
        new_obj.name = "Glasses"

        # Get the armature from the Glasses object's Armature modifier
        armature = None
        for mod in new_obj.modifiers:
            if mod.type == 'ARMATURE':
                armature = mod.object
                break
        if not armature:
            self.report({'ERROR'}, "No armature found for the glasses.")
            return {'CANCELLED'}

        # Select the armature and switch to Pose mode
        bpy.context.view_layer.objects.active = armature
        armature.select_set(True)
        bpy.ops.object.mode_set(mode='POSE')

        # Select the J_Bip_C_Head bone
        if "J_Bip_C_Head" in armature.pose.bones:
            bone = armature.pose.bones["J_Bip_C_Head"]
            bone.bone.select = True
        else:
            self.report({'ERROR'}, "J_Bip_C_Head bone not found.")
            return {'CANCELLED'}

        # Snap the 3D cursor to the head bone
        bpy.ops.view3d.snap_cursor_to_selected()

        # Switch back to Object mode
        bpy.ops.object.mode_set(mode='OBJECT')

        # Select the "Glasses" object
        bpy.ops.object.select_all(action='DESELECT')
        new_obj.select_set(True)
        bpy.context.view_layer.objects.active = new_obj

        # Set origin to 3D cursor (head bone position)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')

        # Move glasses to world origin
        bpy.context.scene.cursor.location = (0, 0, 0)
        bpy.ops.view3d.snap_selected_to_cursor(use_offset=False)

        # Cleanup Materials
        glasses_materials = [slot for slot in new_obj.material_slots if slot.material and 'Glasses' in slot.material.name]
        if not glasses_materials:
            self.report({'WARNING'}, "No materials with 'Glasses' in the name found for the glasses.")
        else:
            default_slot_index = new_obj.material_slots.find(glasses_materials[0].name)
            for poly in new_obj.data.polygons:
                if new_obj.material_slots[poly.material_index] not in glasses_materials:
                    poly.material_index = default_slot_index
            slots_to_remove = [i for i, slot in enumerate(new_obj.material_slots) if slot not in glasses_materials]
            for i in sorted(slots_to_remove, reverse=True):
                new_obj.active_material_index = i
                bpy.ops.object.material_slot_remove()

        # Remove All Vertex Groups
        new_obj.vertex_groups.clear()

        # Remove Shape Keys in Specified Order
        if new_obj.data.shape_keys:
            shape_keys = new_obj.data.shape_keys.key_blocks
            for key in list(shape_keys):
                if "HEAD" in key.name:
                    new_obj.shape_key_remove(key)
            for key in list(shape_keys):
                if key.name != "Basis":
                    new_obj.shape_key_remove(key)
            if "Basis" in shape_keys:
                new_obj.shape_key_remove(shape_keys["Basis"])

        # Remove Armature Modifier
        for mod in new_obj.modifiers:
            if mod.type == 'ARMATURE':
                new_obj.modifiers.remove(mod)
                break

        # Recenter Glasses at Scene Origin
        bpy.ops.object.select_all(action='DESELECT')
        new_obj.select_set(True)
        bpy.context.view_layer.objects.active = new_obj
        bpy.ops.object.origin_set(type='ORIGIN_CENTER_OF_MASS', center='BOUNDS')
        bpy.context.scene.cursor.location = (0, 0, 0)
        bpy.ops.view3d.snap_selected_to_cursor(use_offset=False)

        # Conditional Export and Deletion
        if not context.scene.no_export_glasses:
            # Get the VRM name from the armature
            vrm_extension = armature.data.vrm_addon_extension
            is_vrm_10 = (vrm_extension.spec_version == "1.0")
            if is_vrm_10:
                vrm_name = vrm_extension.vrm1.meta['vrm_name'].replace(' ', '_')
            else:
                vrm_name = vrm_extension.vrm0.meta.title.replace(' ', '_')
            if not vrm_name:
                self.report({'ERROR'}, "VRM model name not found in metadata.")
                return {'CANCELLED'}

            blend_filepath = bpy.data.filepath
            blend_directory = os.path.dirname(blend_filepath)
            export_folder = os.path.join(blend_directory, f"{vrm_name}(BakinVRM)")
            os.makedirs(export_folder, exist_ok=True)
            fbx_export_path = os.path.join(export_folder, f"{vrm_name}_Wear_Glasses.fbx")

            bpy.ops.object.select_all(action='DESELECT')
            new_obj.select_set(True)

            bpy.ops.export_scene.fbx(
                filepath=fbx_export_path,
                use_selection=True,
                global_scale=0.01,
                use_mesh_modifiers=False,
                add_leaf_bones=False,
                use_tspace=True
            )

            bpy.data.objects.remove(new_obj, do_unlink=True)
            self.report({'INFO'}, f"Exported glasses to: {fbx_export_path}")
        else:
            self.report({'INFO'}, "Glasses extracted and cleaned up but not exported or deleted.")

        return {'FINISHED'}
        
class ExtractCatEarsButton(bpy.types.Operator):
    bl_idname = "object.extract_cat_ears"
    bl_label = bpy.app.translations.pgettext("Extract Cat Ears BETA")
    bl_description = bpy.app.translations.pgettext("Isolates any cat ears on your VRM model so that you can load them separately through BAKIN's Subgraphics. At present, you'll need to export this separately through the Blender FBX exporter, select the ears alone, limit export to selected only, then delete it and export the rest of the model through the addon.")

    def execute(self, context):
        obj = bpy.context.object
        
        if obj is None or obj.type != 'MESH':
            self.report({'ERROR'}, "No mesh object selected.")
            return {'CANCELLED'}

        # Ensure we're in Object mode to perform operations
        bpy.ops.object.mode_set(mode='OBJECT')

        # Get vertex groups containing 'cat' (adjust keyword as needed)
        cat_groups = [vgroup for vgroup in obj.vertex_groups if 'cat' in vgroup.name.lower() in vgroup.name.lower() and 'tail' not in vgroup.name.lower()]
        
        if not cat_groups:
            self.report({'WARNING'}, "No vertex groups containing 'cat' found.")
            return {'CANCELLED'}

        # Switch to Edit mode to perform mesh operations
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.select_all(action='DESELECT')
        
        # Iterate over each cat vertex group and select vertices
        for vgroup in cat_groups:
            obj.vertex_groups.active = vgroup  # Set the active vertex group
            bpy.ops.object.vertex_group_select()

        # Separate selected vertices into a new object
        bpy.ops.mesh.separate(type='SELECTED')

        # Switch back to Object mode
        bpy.ops.object.mode_set(mode='OBJECT')

        # Rename the newly created object
        # The newly created object will be the active object after separation
        new_obj = bpy.context.selected_objects[-1]
        new_obj.name = "Cat Ears"

        return {'FINISHED'}

class ExtractRabbitEarsButton(bpy.types.Operator):
    bl_idname = "object.extract_rabbit_ears"
    bl_label = bpy.app.translations.pgettext("Extract Rabbit Ears BETA")
    bl_description = bpy.app.translations.pgettext("Isolates any rabbit ears on your VRM model so that you can load them separately through BAKIN's Subgraphics. At present, you'll need to export this separately through the Blender FBX exporter, select the ears alone, limit export to selected only, then delete it and export the rest of the model through the addon.")

    def execute(self, context):
        obj = bpy.context.object
        
        if obj is None or obj.type != 'MESH':
            self.report({'ERROR'}, "No mesh object selected.")
            return {'CANCELLED'}

        # Ensure we're in Object mode to perform operations
        bpy.ops.object.mode_set(mode='OBJECT')

        # Get vertex groups containing 'rabbit' and not containing 'tail'
        rabbit_groups = [vgroup for vgroup in obj.vertex_groups if 'rabbit' in vgroup.name.lower() and 'tail' not in vgroup.name.lower()]
        
        if not rabbit_groups:
            self.report({'WARNING'}, "No suitable vertex groups containing 'rabbit' found.")
            return {'CANCELLED'}

        # Switch to Edit mode to perform mesh operations
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.select_all(action='DESELECT')
        
        # Iterate over each rabbit vertex group and select vertices
        for vgroup in rabbit_groups:
            obj.vertex_groups.active = vgroup  # Set the active vertex group
            bpy.ops.object.vertex_group_select()

        # Separate selected vertices into a new object
        bpy.ops.mesh.separate(type='SELECTED')

        # Switch back to Object mode
        bpy.ops.object.mode_set(mode='OBJECT')

        # Rename the newly created object
        # The newly created object will be the active object after separation
        new_obj = bpy.context.selected_objects[-1]
        new_obj.name = "Bunny Ears"

        return {'FINISHED'}
    
import re

class OBJECT_OT_export_vrm_for_bakin(bpy.types.Operator):
    bl_idname = "object.export_vrm_for_bakin"
    bl_label = bpy.app.translations.pgettext("Export VRM for Bakin")
    bl_description = bpy.app.translations.pgettext("Exports the scene as a VRM file using the model's name")
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        # Find the armature
        armature = None
        for obj in bpy.data.objects:
            if obj.type == 'ARMATURE' and hasattr(obj.data, "vrm_addon_extension"):
                armature = obj
                break

        if not armature:
            self.report({'ERROR'}, "No valid VRM armature found.")
            return {'CANCELLED'}

        # Extract VRM version and name
        vrm_extension = armature.data.vrm_addon_extension
        is_vrm_10 = (vrm_extension.spec_version == "1.0")
        
        if is_vrm_10:
            vrm_name = vrm_extension.vrm1.meta.get('vrm_name', 'Unnamed').replace(' ', '_')
        else:
            vrm_name = vrm_extension.vrm0.meta.title.replace(' ', '_')

        # Sanitize the VRM name for file system compatibility
        vrm_name = re.sub(r'[<>:"/\\|?*\t\n\r]', '_', vrm_name)

        if not vrm_name:
            self.report({'ERROR'}, "VRM model name not found in metadata.")
            return {'CANCELLED'}

        # Get blend file directory
        blend_filepath = bpy.data.filepath
        if not blend_filepath:
            self.report({'ERROR'}, "Please save the blend file first.")
            return {'CANCELLED'}

        blend_directory = os.path.dirname(blend_filepath)

        # Define export folder and ensure it exists
        export_folder = os.path.join(blend_directory, f"{vrm_name}(BakinVRM)")
        os.makedirs(export_folder, exist_ok=True)

        # Define VRM export file name
        vrm_export_path = os.path.join(export_folder, f"{vrm_name}(BakinVRM).vrm")

        # Export as VRM
        bpy.ops.export_scene.vrm(filepath=vrm_export_path)

        self.report({'INFO'}, f"Exported VRM to: {vrm_export_path}")
        return {'FINISHED'}
    
class ImportBakinFBX(bpy.types.Operator):
    bl_idname = "object.import_fbx_from_bakin"
    bl_label = bpy.app.translations.pgettext("Process FBX for Bakin")
    bl_description = bpy.app.translations.pgettext("Automates importing of the FBX generated by Bakin")
    bl_options = {'REGISTER', 'UNDO'}

    file_type: bpy.props.EnumProperty(
        name="File Type",
        description="Choose the FBX file type to import",
        items=[
            ('humanoid', "VRM Humanoid", "Import the (BakinVRM).vrm.humanoid FBX file"),
            ('mixamo', "Mixamo", "Import the (BakinVRM).vrm.mixamo FBX file"),
            ('x100', "X100", "Import the (BakinVRM).vrm.x100 FBX file"),
            ('legacy', "Legacy VRM FBX", "Import the (BakinVRM).vrm.fbx file (outdated)")
        ],
        default='humanoid'
    )

    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        layout = self.layout
        layout.prop(self, "file_type", text="Select File Type")
        layout.label(text="Choose the FBX file type and click OK to import.")

    def execute(self, context):
        # 1. CHECK IF BLEND FILE IS SAVED
        blend_filepath = bpy.data.filepath
        if not blend_filepath:
            self.report({'ERROR'}, "Please save the blend file first.")
            return {'CANCELLED'}
        
        blend_directory = os.path.dirname(blend_filepath)

        # 2. FIND VRM ARMATURE
        vrm_armature = None
        for obj in bpy.data.objects:
            if obj.type == 'ARMATURE' and hasattr(obj.data, "vrm_addon_extension"):
                vrm_armature = obj
                break

        if not vrm_armature:
            self.report({'ERROR'}, "No valid VRM armature found.")
            return {'CANCELLED'}

        # 3. DETECT VRM VERSION AND GET VRM NAME
        vrm_extension = vrm_armature.data.vrm_addon_extension
        is_vrm_10 = (vrm_extension.spec_version == "1.0")

        if is_vrm_10:
            vrm_name = vrm_extension.vrm1.meta.get("vrm_name", "Unnamed").replace(' ', '_')
        else:
            vrm_name = vrm_extension.vrm0.meta.title.replace(' ', '_')

        if not vrm_name:
            self.report({'ERROR'}, "VRM model name not found in metadata.")
            return {'CANCELLED'}

        # 4. DETERMINE FBX PATH BASED ON SELECTED FILE TYPE
        file_suffix = {
            'humanoid': '.vrm.humanoid.fbx',
            'mixamo': '.vrm.mixamo.fbx',
            'x100': '.vrm.x100.fbx',
            'legacy': '.vrm.fbx'
        }[self.file_type]
        
        fbx_path = os.path.join(blend_directory, f"{vrm_name}(BakinVRM)", f"{vrm_name}(BakinVRM){file_suffix}")
        
        if not os.path.exists(fbx_path):
            self.report({'ERROR'}, f"FBX file not found: {fbx_path}")
            return {'CANCELLED'}

        # 5. IMPORT FBX WITH APPROPRIATE SCALE
        scale = 0.01 if self.file_type == 'x100' else 100.0
        bpy.ops.import_scene.fbx(filepath=fbx_path, global_scale=scale)

        # 6. FIND NEWLY IMPORTED ARMATURE
        imported_armature = None
        for obj in bpy.context.selected_objects:
            if obj.type == 'ARMATURE':
                imported_armature = obj
                break

        if not imported_armature:
            self.report({'ERROR'}, "Failed to find imported armature.")
            return {'CANCELLED'}
        
        # 7. SET THE SCENE FRAME RATE BACK TO 60
        context.scene.render.fps = 60

        self.report({'INFO'}, f"Imported {file_suffix} FBX from: {fbx_path}")
        return {'FINISHED'}
    
class ExportAnimationFromBase(bpy.types.Operator):
    bl_idname = "object.export_base_animation"
    bl_label = bpy.app.translations.pgettext("Export _base_ Animation")
    bl_description = bpy.app.translations.pgettext("Exports the _base_ armature animation as an FBX clip")
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        # 1. Switch to Object Mode to avoid errors
        if bpy.ops.object.mode_set.poll():
            bpy.ops.object.mode_set(mode='OBJECT')

        # 2. Find "_base_" armature
        base_armature = bpy.data.objects.get("_base_")
        if not base_armature or base_armature.type != 'ARMATURE':
            self.report({'ERROR'}, "No '_base_' armature found in the scene.")
            return {'CANCELLED'}

        # 3. Get animation name from scene property
        animation_name = context.scene.animation_name.strip()
        if not animation_name:
            self.report({'ERROR'}, "No animation name provided.")
            return {'CANCELLED'}

        # 4. Check if there's an animation
        if not base_armature.animation_data or not base_armature.animation_data.action:
            self.report({'ERROR'}, "No active animation on '_base_' armature.")
            return {'CANCELLED'}

        # 5. Rename the action
        baked_action = base_armature.animation_data.action
        baked_action.name = animation_name  # Set action name to user input

        # 6. Push the action into NLA as a clip
        # Ensure animation_data exists and create it if necessary
        if not base_armature.animation_data:
            base_armature.animation_data_create()

        # Ensure there’s at least one NLA track
        if not base_armature.animation_data.nla_tracks:
            base_armature.animation_data.nla_tracks.new()

        # Create a new strip in the last NLA track
        nla_track = base_armature.animation_data.nla_tracks[-1]
        start_frame = 1  # Start the clip at frame 1
        nla_strip = nla_track.strips.new(name=animation_name, start=start_frame, action=baked_action)
        nla_strip.extrapolation = 'NOTHING'  # Set extrapolation to None

        # Clear the active action to ensure NLA drives the animation
        base_armature.animation_data.action = None

        # 7. Find VRM model name before deletion
        vrm_armature = bpy.data.objects.get("Armature")
        if not vrm_armature:
            self.report({'ERROR'}, "VRM couldn't be found.")
            return {'CANCELLED'}

        vrm_extension = vrm_armature.data.vrm_addon_extension
        is_vrm_10 = (vrm_extension.spec_version == "1.0")

        if is_vrm_10:
            vrm_name = vrm_extension.vrm1.meta.get("vrm_name", "Unnamed").replace(' ', '_')
        else:
            vrm_name = vrm_extension.vrm0.meta.title.replace(' ', '_')

        if not vrm_name:
            self.report({'ERROR'}, "VRM model name not found in metadata.")
            return {'CANCELLED'}

        # 8. Delete everything except "_base_"
        bpy.ops.object.select_all(action='DESELECT')
        context.view_layer.objects.active = None  # Ensure nothing is active

        to_delete = [obj for obj in bpy.data.objects if obj.name != "_base_"]
        for obj in to_delete:
            bpy.data.objects.remove(obj, do_unlink=True)  # Safe removal

        # 9. Create animations folder inside VRM export folder
        blend_directory = os.path.dirname(bpy.data.filepath)
        vrm_export_folder = os.path.join(blend_directory, f"{vrm_name}(BakinVRM)")
        animations_folder = os.path.join(vrm_export_folder, "animations")
        os.makedirs(animations_folder, exist_ok=True)

        # 10. Export FBX with the clip’s frame range
        # Define the export path for the FBX file
        export_fbx_path = os.path.join(animations_folder, f"{vrm_name}_{animation_name}.fbx")

        # Define the bake range based on the NLA strip’s frames
        bake_start = int(nla_strip.frame_start)  # Start frame of the animation clip
        bake_end = int(nla_strip.frame_end)      # End frame of the animation clip

        # Select only the armature to export
        bpy.ops.object.select_all(action='DESELECT')
        bpy.context.view_layer.objects.active = base_armature
        base_armature.select_set(True)

        # Set the scene’s frame range to the clip’s range
        bpy.context.scene.frame_start = bake_start
        bpy.context.scene.frame_end = bake_end

        # Export the FBX file
        bpy.ops.export_scene.fbx(
            filepath=export_fbx_path,           # Path to save the FBX file
            use_selection=True,                 # Export only the selected armature
            object_types={'ARMATURE'},          # Export armature objects
            global_scale=0.01,                  # Scale for compatibility (e.g., with game engines)
            bake_anim=True,
            bake_anim_use_all_actions=False,
            add_leaf_bones=False                # Avoid adding extra bones
        )

        # Report success
        self.report({'INFO'}, f"Exported animation clip to: {export_fbx_path}")
        return {'FINISHED'}
    
class OBJECT_OT_dialog_operator(bpy.types.Operator):
    bl_idname = "object.dialog_operator"
    bl_label = bpy.app.translations.pgettext("Enter Animation Name")
    
    animation_name: bpy.props.StringProperty(name="Animation Name", default="wait")

    def execute(self, context):
        context.scene.animation_name = self.animation_name
        return {'FINISHED'}

    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)

class RunScriptButtonPanel(bpy.types.Panel):
    bl_label = bpy.app.translations.pgettext("VRoid for Bakin")
    bl_idname = "OBJECT_PT_run_script"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = bpy.app.translations.pgettext("VRoid for Bakin")

    def draw(self, context):
        layout = self.layout

        # Check if the current .blend file is saved
        blend_file_saved = bpy.data.filepath != ""

        # Import section
        layout.label(text=bpy.app.translations.pgettext("Import"), icon='IMPORT')
        layout.operator("object.import_vrm")

        # Bakin Enhancements section
        layout.label(text=bpy.app.translations.pgettext("Bakin Enhancements"), icon='OUTLINER_OB_ARMATURE')
        layout.operator("object.add_item_hooks", icon='EVENT_ONEKEY')
        layout.operator("object.add_eye_shape_keys", icon='EVENT_TWOKEY')

        # Optional Expressions section
        layout.label(text=bpy.app.translations.pgettext("Optional Expressions"), icon='SHADERFX')
        layout.operator("object.create_alternate_irises", icon='VIS_SEL_11')
        layout.operator("object.create_blushing_layer", icon='MATFLUID')

        # Head Tilt section
        layout.label(text=bpy.app.translations.pgettext("Head Tilt"), icon='ORIENTATION_GIMBAL')
        layout.operator("object.add_head_body_shape_keys", icon='EVENT_THREEKEY')
        layout.operator("object.fusion_and_add_bonuses", icon='EVENT_FOURKEY')

        # Export section
        layout.label(text=bpy.app.translations.pgettext("Split/Export/Delete Subgraphics"), icon='EXPORT')

        # Display warning if blend file is not saved
        if not blend_file_saved:
            layout.label(text=bpy.app.translations.pgettext("Warning: Blend file not saved!"), icon='ERROR')

        # Extract Glasses button
        glasses_button = layout.row()
        glasses_button.enabled = blend_file_saved
        glasses_button.operator("object.extract_glasses", icon='HIDE_OFF')

        # Add "No Export" toggle for glasses
        layout.prop(context.scene, "no_export_glasses", text=bpy.app.translations.pgettext("Separate Only Mode"))

        # Export section
        layout.label(text=bpy.app.translations.pgettext("Export VRM for Bakin"), icon='EXPORT')

        # Export buttons
        vrm_export_button = layout.row()
        vrm_export_button.enabled = blend_file_saved
        vrm_export_button.operator("object.export_vrm_for_bakin", text=bpy.app.translations.pgettext("VRM Export"), icon='EXPORT')

        export_button = layout.row()
        export_button.enabled = blend_file_saved
        export_button.operator("object.export_fbx_unified", text=bpy.app.translations.pgettext("FBX+DEF Export (Legacy)"), icon='EXPORT')

        # Animation section
        layout.label(text=bpy.app.translations.pgettext("Animation Exporter"), icon='EXPORT')

        addon_module_name = "blender-animation-retargeting-stable"
        addon_installed = False
        for addon in bpy.context.preferences.addons:
            if addon.module == addon_module_name:
                addon_installed = True
                break

        if addon_installed:
            layout.label(text=bpy.app.translations.pgettext("Animation Retargeting is installed."), icon='CHECKMARK')
            layout.operator("object.import_fbx_from_bakin", text=bpy.app.translations.pgettext("Import Bakin Retarget Model"), icon='ANIM_DATA')
            layout.prop(context.scene, "animation_name", text=bpy.app.translations.pgettext("Anim Name"))
            layout.operator("object.export_base_animation", text=bpy.app.translations.pgettext("Export _base_ Animation"), icon='ANIM')
        else:
            layout.label(text=bpy.app.translations.pgettext("Animation Retargeting not found. Please download:"))
            download_link = layout.row()
            download_link.operator("wm.url_open", text=bpy.app.translations.pgettext("Download Animation Retargeting"), icon='URL').url = "https://github.com/Mwni/blender-animation-retargeting"

        export_descriptions = [
            bpy.app.translations.pgettext("VRM only: import the model into Bakin before animating!")
        ]
        for export_desc in export_descriptions:
            for line in textwrap.wrap(export_desc, width=40):
                layout.label(text=line, icon='BLANK1')


def register():
    bpy.utils.register_class(ImportVRMButton)
    bpy.utils.register_class(OBJECT_OT_export_vrm_for_bakin)
    bpy.utils.register_class(AddItemHooksButton)
    bpy.utils.register_class(AddEyeShapeKeysButton)
    bpy.utils.register_class(AddHeadBodyShapeKeysButton)
    bpy.utils.register_class(FusionAndAddBonusesButton)
    bpy.utils.register_class(ExtractGlassesButton)
    bpy.utils.register_class(ExtractRabbitEarsButton)
    bpy.utils.register_class(ExtractCatEarsButton)
    bpy.utils.register_class(ExportFBXUnifiedButton)
    bpy.utils.register_class(RunScriptButtonPanel)
    bpy.utils.register_class(ImportBakinFBX)
    bpy.utils.register_class(CreateAlternateIrisesButton)
    bpy.utils.register_class(CreateBlushingLayerButton)
    bpy.utils.register_class(ExportAnimationFromBase)
    bpy.utils.register_class(OBJECT_OT_dialog_operator)
    
    bpy.types.Scene.animation_name = bpy.props.StringProperty(name=bpy.app.translations.pgettext("Animation Name"), default="Idle")
    bpy.types.Scene.no_export_glasses = bpy.props.BoolProperty(name=bpy.app.translations.pgettext("No Export Glasses"), default=False)
    
    register_translations()

def unregister():
    bpy.utils.unregister_class(ImportVRMButton)
    bpy.utils.unregister_class(AddItemHooksButton)
    bpy.utils.unregister_class(OBJECT_OT_export_vrm_for_bakin)
    bpy.utils.unregister_class(AddEyeShapeKeysButton)
    bpy.utils.unregister_class(AddHeadBodyShapeKeysButton)
    bpy.utils.unregister_class(FusionAndAddBonusesButton)
    bpy.utils.unregister_class(ExportFBXUnifiedButton)
    bpy.utils.unregister_class(ExtractGlassesButton)
    bpy.utils.unregister_class(ExtractRabbitEarsButton)
    bpy.utils.unregister_class(ExtractCatEarsButton)
    bpy.utils.unregister_class(ImportBakinFBX)
    bpy.utils.unregister_class(CreateAlternateIrisesButton)
    bpy.utils.unregister_class(CreateBlushingLayerButton)
    bpy.utils.unregister_class(RunScriptButtonPanel)
    bpy.utils.unregister_class(ExportAnimationFromBase)
    bpy.utils.unregister_class(OBJECT_OT_dialog_operator)
    del bpy.types.Scene.animation_name
    del bpy.types.Scene.no_export_glasses
    
    unregister_translations()

if __name__ == "__main__":
    register()
